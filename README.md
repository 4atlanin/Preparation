# Spring MVC
Servlet - интерфейс расширяющий функциональность сервера. Принимает, процессит реквесты и возвращает респонсы. 
DispatcherServlet - front controller, основной сервлет, распределяет реквесты по контроллерам. Их может быть несколько в приложении.
WebApplicationInitializer – интерфейс, предоставляемый Spring MVC, который гарантирует инициализацию при старте контейнера. Тут можно настроить DispatcherServlet
#### Request life cycle
![alt text](https://javastudy.ru/wp-content/uploads/2015/04/RequestLifecycle.png)
![alt text](https://justforchangesake.files.wordpress.com/2014/05/spring-request-lifecycle.jpg)
![alt text](https://javastudy.ru/wp-content/uploads/2015/04/SpringMVC-detail.jpg)
 1. запрос от клиента сперва проходит через фильтры, `javax.servlet.Filter`. Пример - `CorsFilter`, или можно свои запилить.
 2. Попадает в `DispatcherServlet`:
    - в реквест аттачится `WebApplicationContext`, `LocalResolver`, `ThemeResolver`.
    - если реквест мультипарт, то он заворачивается в `MultipartHttpServletRequest`. 
    - ищется подходящий хэндлер, `DefaultAnnotationHandlerMapping` который далее смотрит свои настройки, чтобы понять какой контроллер использовать 
    (на рисунке Handler Mapping) по сопоставлению аннотации `@RequestMapping` и реквеста.
    Реализации HandlerMapping могут поддерживать перехватчики (interceptors), но не содержат их. 
    Обработчик будет всегда обернут в экземпляре HandlerExecutionChain, возможно в сопровождении некоторых экземпляров HandlerInterceptor. 
    DispatcherServlet сначала вызывает  метод preHandle каждого HandlerInterceptor в заданном порядке, и в конце, внедряет обработчик, 
    если все методы preHandle вернули true.
    По умолчанию интерфейс HandlerMapping в Spring MVC реализуется классом `RequestMappingHandlerMapping`. Существуют другие реализации интерфейса, 
    которые используют другие параметры для поиска контроллера, соответствующего запросу.
    
    ```
    Following are the different mapping types supported.
    
    By path
    @RequestMapping(“path”)
    
    By HTTP method
    @RequestMapping(“path”, method=RequestMethod.GET). Other Http methods such as POST, PUT, DELETE, OPTIONS, and TRACE are also supported.
    
    By query parameter
    @RequestMapping(“path”, method=RequestMethod.GET, params=”param1”)
    
    By the presence of request header
    @RequestMapping(“path”, header=”content-type=text/*”)
    ```
    
    - `HandlerInterceptor.preHandle` если есть в конфигурации(добавляются через `WebMvcConfigurer`)
    - Попали в контроллер, сделали все дела.
    - Если ошибка то попадаем в **Handler exception resolver** , по дефолту используется `DefaultHandlerExceptionResolver`.  
    Можно сделать свой и пометить метод, принимающий `Throwable`, аннотацией `@ExceptionHandler`.
    - Возвращаемся через `HandlerInterceptor.postHandle` если есть в конфигурации
3. Попадает в `DispatcherServlet` 
4. Если нет аннотации `@ResponseBody`, то ViewResolver мапит имя view на конкретную имплементацию, например **FreeMarkerViewResolver**. Если есть `@ResponseBody` то возвращается респонс как есть.
    
    `ViewResolver` – интерфейс, реализуемый объектами, которые способны находить представления View по имени View Name.
    Состояние представления не изменяется во время выполнения приложения и поэтому в реализации возможно применять кэширование.
    Реализации могут поддерживать интернационализацию, т.е. локализировать представления.
    После того как в модель modelAndView было записано имя представления viewName = ‘index’ 
    и произошел выход из метода, то в действие включается ViewResolver. Для этого примера согласно настройкам в dispatcher-servlet.xml 
    класс `InternalResourceViewResolver` будет искать представление с именем index, у которого префикс `/WEB-INF/views/`, а суффикс **.jsp**. 
    Другими словами он должен найти представление с именем **/WEB-INF/views/index.jsp**. Если представление найдено, то произойдет переход на эту страницу. 
    В противном случае результат зависит от настроек реализации интерфейса ViewResolver. По умолчанию возвращается _null_, но можно возвращать имя или исключение, если вам это необходимо.
    
#### Servlets, JSP
##### Servlets
Для обработки запроса в HttpServlet определен ряд методов, которые мы можем переопределить в классе сервлета:
- _doGet_: обрабатывает запросы GET (получение данных)
- _doPost_: обрабатывает запросы POST (отправка данных)
- _doPut_: обрабатывает запросы PUT (отправка данных для изменения)
- _doDelete_: обрабатывает запросы DELETE (удаление данных)
- _doHead_: обрабатывает запросы HEAD

Для определения сервлета может использоваться аннотация `@WebServlet`, которая устанавливала конечную точку, с которой сопоставлялся сервлет. 

Или мы можем определить его в `web.xml`. Прежде всего вначале с помощью элемента _<servlet>_ определяется сервлет. Элемент _<servlet-name>_ задает имя сервлета, на которое будет проецироватья класс, указанный в элементе _<servlet-class>_. То есть, допустим, у нас проекте есть класс сервлета _HelloServlet_, 
 который будет проецироваться на имя _HelloWorld_. Имя может быть произвольным и может совпадать с названием класса.
 
```<?xml version="1.0" encoding="UTF-8"?>
<web-app xmlns="http://xmlns.jcp.org/xml/ns/javaee"
  xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
  xsi:schemaLocation="http://xmlns.jcp.org/xml/ns/javaee
                      http://xmlns.jcp.org/xml/ns/javaee/web-app_4_0.xsd"
  version="4.0">
   
  <servlet>
      <servlet-name>HelloWorld</servlet-name>
      <servlet-class>HelloServlet</servlet-class>
   </servlet>
    
  <servlet-mapping>
    <servlet-name>HelloWorld</servlet-name>
    <url-pattern>/welcome</url-pattern>
  </servlet-mapping>
   
</web-app>
```
###### Передача параметров в сервлет

Элемент **<context-param>** в файле `web.xml` задает параметр, которым инициализируются сервлеты. Внутри этого элемента с помощью элемента <param-name> задается имя параметра, а с помощью элемента **<param-value>** - значение параметра.

```
  <context-param>
    <param-name>message</param-name>
    <param-value>Hello Servlets</param-value>
  </context-param>
```

Для получения параметра внутри сервлета необходимо обратиться к контексту сервлета. Для его получения внутри класса сервлета определен метод getServletContext(). Он возвращает объект ServletContext. Затем у этого объекта вызывается метод getInitParameter(), в который передается название параметра инициализации.

###### Обработка ошибок

Файл web.xml позволяет указать, какие страницы html или jsp будут отправляться пользователю при отправке статусных кодов ошибок. Для этого в `web.xml` применяется элемент **<error-page>**.
```
  <error-page>
    <error-code>404</error-code>
    <location>/404.html</location>
  </error-page>
```

Кроме настройки обработки стандартных ошибок протокола http,типа 404 или 403, файл `web.xml` позволяет настроить обработку исключений, которые могут возникнуть при обработке запроса. Для этого в `web.xml` применяется элемент **<exception-type>**.
```
  <error-page>
    <exception-type>java.lang.Throwable</exception-type>
    <location>/error.jsp</location>
  </error-page>
```

###### Cookies
Куки представляют простейший способо хранения данных приложения. Куки хранятся в браузере польвователя в виде пары ключ-значение: с каждым уникальным ключом сопоставлется определенное значение. По ключу мы можем получить сохраненное в куках значение. Приложение на сервере может устанавливать куки и отправлять в ответе пользователю, после чего куки сохраняются в браузере. 
Когда клиент отправляет запроск приложению, то в запросе также отправляются и те куки, которые установленны данным приложением.

Куки могут быть двух типов. 
- Одни куки хранятся только в течении сеанса. То есть когда пользователь закрывает вкладку браузера и прекращает работать с приложением, то куки сеанса уничтожаются. 
- Второй тип куков - постоянные куки - хранятся в течение продолжительного времени (до 3 лет).

Следует учитывать некоторые ограничения. Прежде всего куки нередко ограничены по размеру (обычно не более 4 килобайт). Кроме того, обычно браузеры принимают не более 20 кук с одного сайта. Более того, в некоторых браузерах может быть отключена поддержка кук.
Для работы с куками сервлеты могут используют класс _javax.servlet.http.Cookie_. Для создания куки надо создать объект этого класса с помощью констуктора Cookie(String name, String value), где name - ключ, а value - значение, которое сохраняется в куках.

Стоит отметить, что мы можем сохранить в куках только строки.
Чтобы добавить куки в ответ клиенту у объекта HttpServletResponse применяется метод addCookie(Cookie c)
При создании куки мы можем использовать ряд методов объекта Cookie для установки и получения отдельных параметров:

- _setMaxAge(int maxAgeInSeconds)_: устанавливает время в секундах, в течение которого будут существовать куки. Специальное значение -1 указывает, что куки будут существовать только в течение сессии и после закрытия браузера будут удалены.
- _setValue(String value)_: устанавливает хранимое значение.
- _getMaxAge()_: возвращает время хранения кук.
- _getName()_: возвращает ключ кук.
- _getValue()_: возвращает значение кук.

Чтобы получить куки, которые приходят в запросе от клиента, применяется метод getCookies() класса HttpServletRequest.

###### Session 

Сессия позоляет сохранять некоторую информацию на время сеанса. Когда клиент обращается к сервлету или странице JSP, то движок сервлетов проверяет, определен ли в запросе параметр ID сессии. Если такой параметр неопределен (например, клиент первый раз обращается к приложению), 
тогда движок сервлетов создает уникальное значение ID и связанный с ним объект сессии. Объект сессии сохраняется на сервере, а ID оправляется в ответе клиенту и по умолчанию сохраняется на клиенте в куках. Затем когда приходит новый запрос от того же клиента, 
то движок сервлетов опять же может получить ID и сопоставить его с объектом сессии на веб-сервере.

Хотя по умолчанию ID сессии хранится в куках, но возможна ситуация, когда куки отключены на клиенте. Для решения этой проблемы есть ряд техник, в частности, добавление ID в адрес.
Для получения объекта сессии в сервлете у объекта `HttpServletRequest` определен метод _getSession()_. Он возвращает объект `HttpSession`.

Для управления сессией объект HttpSession предоставляет ряд методов:

- _setAttribute(String name, Object o)_: сохраняет в сессии под ключом name
- _getAttribute(String name)_: возвращает из сессии объект с ключом name. Если ключа name в сессии неопределено, то возвращается null
- _removeAttribute(String name)_: удаляет из сессии объект с ключом name
- _getAttributeNames()_: возвращает объект java.util.Enumeration, который содержит все ключи имеющих в сессии объектов
- _getId()_: возвращает идентификатор сессии в виде строки
- _isNew()_: возвращает true, если для клиента еще не установлена сессия (клиент сделал первый запрос или на клиенте отключены куки)
- _setMaxInactiveInterval(int seconds)_: устанавливает интервал неактивности в секундах. И если в течение этого интервала клиент был неактивен, то данные сессии данные удаляются. По умолчанию максимальный интервал неактивности 1800 секунд. Значение -1 указывает, что сессия удаляется только тогда, когда пользователь закрыл вкладку в браузере.
- _invalidate()_: удаляет из сессии все объекты
###### Жизненный цикл сервлетов.
![alt text](https://www.guru99.com/images/2/022220_0728_ServletvsJS1.png)
Жизненный цикл сервлета
Для каждого сервлета движок сервлетов создает только одну копию. Вне зависимости от того, сколько запросов будет отправлено сервлету, все запросы будут обрабатываться толькой одной копией сервлета. 
Объект сервлета создается либо при запуске движка сервлетов, либо когда сервлет получает первый запрос. Затем для каждого запроса запускается поток, который обращается к объекту сервлета.
Поскольку для обработки всех запросов создается один экземпляр сервлета, и все обращения к нему идут в отдельных потоках, то не рекомендуется в классе сервлета объявлять и использовать глобальные переменные, так как они не будут потокобезопасными.

При работе с сервлетом движок сервлетов вызывает у класса сервлета ряд методов, которые определены в родительском абстрактном классе HttpServlet.

- Когда движок сервлетов создает объект сервлета, у сервлета вызывается метод init().

    ``
    public void init(ServletConfig config) throws ServletException { }
    ``

  
  Этот метод вызывается только один раз - при создании сервлета. Мы можем переопределить этот метод, чтобы определить в нем некоторую логику инициализации.

- Когда к сервлету приходит запрос, движок сервлетов вызывает метод service() сервлета. А этот метод, исходя из типа запроса (GET, POST, PUT и т.д.) решает, какому методу сервлета (doGet, doPost и т.д.) 
обрабатывать этот запрос.

``
public void service(HttpServletRequest request, HttpServletResponse response) 
        throws IOException, ServletException
{ }
``

Этот метод также можно переопределить, однако в этом нет смысла. В реальности для обработки запроса переопределяются методы onGet, onPost и т.д., которые обрабатывают конкретные типы запросов.

- Если объект сервлета долгое время не используется (к нему нет никаких запросов), или если происходит завершение работы движка сервлетов, то движок сервлетов выгружает из памяти все созданные экземпляры сервлетов. Однако до выгрузки сервлета из памяти у сервлета вызывается метод destroy().

``
public void destroy()
``

 При необходимости мы также можем его переопределить, например, определить в нем логику логгирования или что иное. В то же время следует учитывать, что если сервер вдруг упадет по какой-то причине, например, отключится электричество и т.д., тогда данный метод естественно не будет вызван и его логика не сработает.
__
##### JSP
ava Server Pages представляет технологию, которая позволяет создавать динамические веб-страницы.
По сути Java Server Page или JSP представляет собой html-код с вкраплениями кода Java. В то же время станицы jsp - это не стандартные html-страницы. Когда приходит запрос к определенной странице JSP, то сервер обрабатывает ее, генерирует из нее код html и отправляет его клиенту.
В итоге пользователь после обращения к странице JSP видит в своем браузере обычную html-страницу.

Как и обычные статические веб-страницы, файлы JSP необходимо размещать на веб-сервере, к которому обычные пользователи могут обращаться по протоколу http, например, набирая в адресной строке браузера нужный адрес. Однако чтобы сервер мог обрабатывать файлы JSP, он должен использовать движок JSP (JSP engine), который также называют JSP-контейнером.
Есть множество движков JSP, и все они реализуют одну и ту же спецификацию и в целом работают одинаково. Однако тем не менее при переносе кода с одного веб-сервера на другой могут потребоваться небольшие изменения.

###### Синтаксис

Содержимое страницы JSP фактически делится на код html (а также css/javascript) и код на языке java. Для вставки кода Java на страницу JSP можно использовать пять основных элементов:

- Выражения JSP (JSP Expression)
- Скриплет JSP (JSP Scriplet)
- Объявления JSP (JSP Declarationб методов и прочее)
- Директивы JSP (JSP Directive, импорты всякие)
- Комментарии JSP;

###### Вложение JSP страниц

В одну JSP-страницу можно вставлять несколько других. Это позволяет определять некоторые общие блоки для всех страниц и использовать их повторно на нескольких страницах JSP.
Для этого применяется специальный тег `jsp:include`, который может использоваться как обычный html-элемент на страницах JSP.

###### Получение отправленных форм
Станицы JSP могут получать отправленные данные, например, через параметры или в виде отправленных форм, так же, как это происходит в сервлете. Для этого внутри страницы jsp доступен объект request, который позволяет получить данные посредством следующих методов:

- _getParameter(String param)_: возвращает значение определенного параметра, название которого передается в метод. Если указанного параметра в запросе нет, то возвращается значение null.
- _getParameterValues(String param)_: возвращает массив значений, который представляет определенный параметр. Если указанного параметра в запросе нет, то возвращается значение null.
###### Передача данных из сервлета в jsp

Нередко страница jsp обрабатывает запрос вместе сервлетом. В этом случае сервлет определяет логику, а jsp - визуальную часть. И при обработке запроса сервлет может перенаправить дальнейшую обработку странице jsp. Соответственно может возникнуть вопрос, как передать данные из сервлета в jsp?
Есть несколько способов передачи данных из сервлета в jsp, которые заключаются в использовании определенного контекста или scope. Есть несколько контекстов для передачи данных:

- _request_ (контекст запроса): данные сохраняются в `HttpServletRequest`
- _session_ (контекст сессии): данные сохраняются в `HttpSession`
- _application_ (контекст приложения): данные сохраняются в `ServletContext`

Данные из контекста запроса доступны только в пределах текущего запроса. 
Данные из контекста сессии доступны только в пределах текущего сеанса. 
А данные из контекста приложения доступны постоянно, пока работает приложение.

Но вне зависимости от выбранного способа передача данных осуществляется с помощью метода setAttribute(name, value), где name - строковое название данных, а value - сами данные, которые могут представлять различные данные.
Наиболее распространенный способ передачи данных из сервлета в jsp представляют атрибуты запроса. То есть у объекта `HttpServletRequest`, который передается в сервлет, вызывается метод setAttribute(). Этот метод устанавливает атрибут, который можно получить в jsp.

###### Expression language
Expression Language или сокращенно EL предоставляет компактный синтаксис для обращения к массивам, коллекциям, объектам и их свойствам внутри страницы jsp. Он довольн прост.
Вставку окрывает знак $, затем в фигурные скобки {} заключается выводимое значение.
По умолчанию Expression Language предоставляет ряд встроенных объектов, которые позволяют использовать различные аспекты запроса:

- _param_: объект, который хранит все переданные странице параметры
- _paramValues_: хранит массив значений для определенного параметра (если для параметра передается сразу несколько значений)
- _header_: хранит все заголовки запроса
- _headerValues_: предоставляет массив значений для определенного заголовка запроса
- _cookie_: предоставляет доступ к отправленным в запросе кукам
- _initParam_: возвращает значение для определенного параметра из элемента context-param из файла web.xml
- _pageContext_: предоставляет доступ к объекту PageContext, который представляет контекст текущей страницы jsp